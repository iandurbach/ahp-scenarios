generate_state_evaluations <- function(baseA, p, skewbase = 0, skewrange = 0.001, stddevbase, stddevrange){
  
  Ni <- nrow(baseA[[1]])
  J <- ncol(baseA[[1]])
  Ns <- length(baseA)
  
  # generate evaluations in each state by perturbing the evaluations in each future
  # for alt i, att j, future k, generate n_B state evaluations. States for (i,j,k) are
  # generated by adding perturbations B[i,j,k,1:n_B] to the baseline evaluation A[i,j,k].
  # The perturbations in B are drawn from a distribution unique to (i,j,k).
  
  # Perturbations for (i,j,k) are generated from a gamma dbn and then standardised to have zero mean. 
  # Its easier to specify the skew and sd you want and then work out the gamma pars from there.
  # Remember, one scale and shape parameter for each (i,j,k) combo
  
  skew_B <- skewbase + skewrange * runif(Ni * J * Ns, 0, 1)		# user-defnd skewness
  sd_B <- stddevbase + stddevrange * runif(Ni * J * Ns, 0, 1)  	# user-defnd stdev
  
  shape_B <- (2 / abs(skew_B)) ^ 2
  scale_B <- sd_B / sqrt(shape_B)
  
  # how many to generate in each future
  n_B <- p[rep(1:Ns, each = Ni * J)]
  
  # generate them
  B <- pmap(list(shape = shape_B, scale = scale_B, n = n_B - 1), rgamma)
  
  # standardise to have zero mean
  B <- map2(.x = as.list(skew_B), .y = B, .f = ~ sign(.x) * (.y - mean(.y)))
  
  # pertubations in the first state of each future are set to zero
  B <- lapply(B, function(x){c(0,x)})
  
  # add the baseline evaluations to the perturbations to get the state evaluations
  # when you unlist baseA it unlists first by col (attributes) then row (alternatives)
  # then dim 3 (futures). Perturbations don't depend on alt or att but different numbers
  # of states are used in each future, so need to be careful to align .x and .y below.
  # (the current way below works). The returned Z object is a list of length Ni * J * Ns,
  # attribute and then by alternative and then by future. Each element contains the state evaluations
  # for that combo of (i,j,k). 
  # EG: if Ni = 9, J = 5, Ns = 10
  # Z[[3]] contains evaluations for attribute 1, alternative 3, future 1).
  # Z[[10]] contains evaluations for attribute 2, alternative 1, future 1).
  # EG: Z[[46]] contains evaluations for attribute 1, alternative 1, future 2).
  Z <- map2(.x = as.list(unlist(baseA)), .y = B, .f = ~ .x + .y)
  
  # create a tidy data frame with alt, att, future, state indices and associated evaluation
  
  # create an alternative index 
  alt_index <- map(.x = p, .f = function(x, Ni, J){rep(rep(1:Ni, times = rep(x, Ni)), J)}, Ni = Ni, J = J)
  alt_index <- unlist(alt_index)
  
  # create a criterion index
  crit_index <- map(.x = p, .f = function(x, Ni, J){rep(1:J, times = rep(x*Ni, J))}, Ni = Ni, J = J)
  crit_index <- unlist(crit_index)
  
  # create a future index
  future_index <- rep(1:Ns, times = Ni * J * p)
  
  # create a state index
  state_index <- map(.x = p, .f = function(x, Ni, J){rep(1:x, times = Ni * J)}, Ni = Ni, J = J)
  state_index <- unlist(state_index)
  
  # make the data frame
  Z_df <- data.frame(i = alt_index,
                     j = crit_index,
                     k = future_index,
                     l = state_index,
                     z = unlist(Z))
  
  # standardise Z within each criterion to have min U[0.1,0.15] and max U[0.75,0.9]
  # I do this so that the max ratio is somewhere between 6 and 9.
  Zs_df <- Z_df %>% group_by(j) %>% 
    mutate(minz = runif(1, 0.1, 0.15),
           maxz = runif(1, 0.75, 0.9),
           z = minz + (maxz - minz) * ((z - min(z)) / (max(z) - min(z)))) %>%
    ungroup() %>%
    select(-minz, -maxz) %>%
    group_by(j,k,l) %>%
    mutate(v = get_AHP_scores(z)) %>%
    arrange(k,l,j)
  
  return(Zs_df)
  
}
